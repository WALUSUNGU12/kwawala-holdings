import React, { useState, useEffect } from 'react';
import { useNavigate, useParams, useSearchParams } from 'react-router-dom';
import { useFormik, FormikHelpers } from 'formik';
import * as Yup from 'yup';
import {
  Box,
  Button,
  Card,
  CardContent,
  CardHeader,
  Chip,
  CircularProgress,
  Divider,
  FormControl,
  FormHelperText,
  Grid,
  InputAdornment,
  InputLabel,
  MenuItem,
  Select,
  TextField,
  Typography,
} from '@mui/material';
import PendingActionsIcon from '@mui/icons-material/PendingActions';
import CheckCircleIcon from '@mui/icons-material/CheckCircle';
import CancelIcon from '@mui/icons-material/Cancel';
import { LocalizationProvider } from '@mui/x-date-pickers';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import { DatePicker } from '@mui/x-date-pickers/DatePicker';
import { 
  useCreateExpenseMutation, 
  useUpdateExpenseMutation, 
  useGetExpenseByIdQuery,
  ExpensePayload,
  ExpenseFormValues,
  Project,
  RootState,
  AuthUser
} from '../features/expenses/expenseTypes';
import { useGetProjectsQuery } from '../features/projects/projectsApi';

// Simple implementation of useAppSelector if not available
const useAppSelector = <T,>(selector: (state: RootState) => T): T => {
  // In a real app, this would come from Redux
  return {} as T;
};

// Categories for the expense form
const categories = [
  { value: 'office', label: 'Office Supplies' },
  { value: 'travel', label: 'Travel' },
  { value: 'utilities', label: 'Utilities' },
  { value: 'equipment', label: 'Equipment' },
  { value: 'other', label: 'Other' },
];

interface ExpenseFormProps {
  // Add any props you need here
}

const ExpenseForm: React.FC<ExpenseFormProps> = () => {
  const navigate = useNavigate();
  const { id } = useParams<{ id?: string }>();
  const { user } = useAppSelector((state) => state.auth);
  const isEditMode = Boolean(id);
  const isAdmin = user?.role === 'admin';

  // Get projectId from query params for new expenses
  const [searchParams] = useSearchParams();
  const defaultProjectId = searchParams.get('projectId') || '';

  // API Hooks
  const [createExpense] = useCreateExpenseMutation();
  const [updateExpense] = useUpdateExpenseMutation();
  const { 
    data: existingExpense, 
    isLoading: isLoadingExpense,
    isError: isExpenseError
  } = useGetExpenseByIdQuery(id || '', { skip: !id });
  
  const { data: projects = [] } = useGetProjectsQuery();
  
  // Loading state for the form
  const [isSubmitting, setIsSubmitting] = useState(false);

  // Handle form submission
  const handleSubmit = async (
    values: ExpenseFormValues, 
    { setSubmitting }: FormikHelpers<ExpenseFormValues>
  ) => {
    try {
      setIsSubmitting(true);
      const expenseData: ExpensePayload = {
        projectId: values.projectId,
        description: values.description,
        amount: values.amount,
        date: values.date instanceof Date ? values.date.toISOString() : values.date,
        category: values.category,
        status: values.status,
        receiptUrl: values.receiptUrl || ''
      };

      if (isEditMode && id) {
        await updateExpense({ 
          id, 
          body: expenseData 
        }).unwrap();
      } else {
        await createExpense(expenseData).unwrap();
      }

      navigate('/expenses');
    } catch (error) {
      console.error('Failed to save expense:', error);
      // In a real app, you'd show this error to the user
    } finally {
      setSubmitting(false);
      setIsSubmitting(false);
    }
  };

  // Formik initialization
  const formik = useFormik<ExpenseFormValues>({
    initialValues: {
      projectId: defaultProjectId,
      date: new Date(),
      description: '',
      amount: '',
      category: 'office',
      status: 'pending',
      receiptUrl: ''
    },
    validationSchema: Yup.object({
      projectId: Yup.string().required('Project is required'),
      date: Yup.date()
        .required('Expense date is required')
        .max(new Date(), 'Expense date cannot be in the future'),
      description: Yup.string()
        .required('Description is required')
        .max(500, 'Description is too long (max 500 characters)'),
      amount: Yup.string()
        .required('Amount is required')
        .matches(/^\d+(\.\d{1,2})?$/, 'Enter a valid amount'),
      category: Yup.string().required('Category is required'),
      status: Yup.string()
        .oneOf(['pending', 'approved', 'rejected'] as const)
        .required('Status is required'),
      receiptUrl: Yup.string().url('Must be a valid URL').nullable(),
    }),
    onSubmit: handleSubmit,
    enableReinitialize: true,
  });

  // Set initial values when editing
  useEffect(() => {
    if (existingExpense) {
      formik.setValues({
        projectId: existingExpense.projectId,
        date: existingExpense.date ? new Date(existingExpense.date) : new Date(),
        description: existingExpense.description || '',
        amount: existingExpense.amount,
        category: existingExpense.category,
        status: existingExpense.status,
        receiptUrl: existingExpense.receiptUrl || ''
      });
    }
  }, [existingExpense]);

  const handleCancel = () => navigate(-1);

  // Loading state
  if (isLoadingExpense) {
    return (
      <Box display="flex" justifyContent="center" p={3}>
        <CircularProgress />
      </Box>
    );
  }

  // Error state
  if (isExpenseError) {
    return (
      <Box p={3}>
        <Typography color="error">
          Error loading expense data. Please try again.
        </Typography>
      </Box>
    );
  }

  return (
    <LocalizationProvider dateAdapter={AdapterDateFns}>
      <form onSubmit={formik.handleSubmit} noValidate>
        <Card>
          <CardHeader
            title={isEditMode ? 'Edit Expense' : 'New Expense'}
            titleTypographyProps={{ variant: 'h6' }}
            action={
              isEditMode && (
                <Chip 
                  label={formik.values.status.toUpperCase()} 
                  color={
                    formik.values.status === 'approved' ? 'success' : 
                    formik.values.status === 'rejected' ? 'error' : 'warning'
                  } 
                  size="small"
                  sx={{ textTransform: 'uppercase', fontWeight: 'bold' }}
                  icon={
                    formik.values.status === 'approved' ? <CheckCircleIcon /> :
                    formik.values.status === 'rejected' ? <CancelIcon /> : <PendingActionsIcon />
                  }
                />
              )
            }
          />
          <Divider />
          <CardContent>
            <Grid container spacing={3}>
              {/* Project Selection */}
              <Grid item xs={12} md={6}>
                <FormControl 
                  fullWidth 
                  error={formik.touched.projectId && Boolean(formik.errors.projectId)}
                >
                  <InputLabel>Project *</InputLabel>
                  <Select
                    name="projectId"
                    value={formik.values.projectId}
                    onChange={formik.handleChange}
                    onBlur={formik.handleBlur}
                    label="Project *"
                    disabled={isSubmitting}
                  >
                    {projects.map((project: Project) => (
                      <MenuItem key={project.id} value={project.id}>
                        {project.name}
                      </MenuItem>
                    ))}
                  </Select>
                  {formik.touched.projectId && formik.errors.projectId && (
                    <FormHelperText error>{formik.errors.projectId}</FormHelperText>
                  )}
                </FormControl>
              </Grid>

              {/* Date */}
              <Grid item xs={12} md={6}>
                <DatePicker
                  label="Date *"
                  value={formik.values.date}
                  onChange={(date) => formik.setFieldValue('date', date)}
                  renderInput={(params) => (
                    <TextField
                      {...params}
                      fullWidth
                      error={formik.touched.date && Boolean(formik.errors.date)}
                      helperText={formik.touched.date && formik.errors.date}
                      onBlur={formik.handleBlur}
                      name="date"
                    />
                  )}
                />
              </Grid>

              {/* Description */}
              <Grid item xs={12}>
                <TextField
                  fullWidth
                  label="Description *"
                  name="description"
                  value={formik.values.description}
                  onChange={formik.handleChange}
                  onBlur={formik.handleBlur}
                  error={formik.touched.description && Boolean(formik.errors.description)}
                  helperText={formik.touched.description && formik.errors.description}
                  disabled={isSubmitting}
                  multiline
                  rows={3}
                />
              </Grid>

              {/* Amount */}
              <Grid item xs={12} md={6}>
                <TextField
                  fullWidth
                  label="Amount *"
                  name="amount"
                  type="number"
                  value={formik.values.amount}
                  onChange={formik.handleChange}
                  onBlur={formik.handleBlur}
                  error={formik.touched.amount && Boolean(formik.errors.amount)}
                  helperText={formik.touched.amount && formik.errors.amount}
                  disabled={isSubmitting}
                  InputProps={{
                    startAdornment: (
                      <InputAdornment position="start">MWK</InputAdornment>
                    ),
                  }}
                />
              </Grid>

              {/* Category */}
              <Grid item xs={12} md={6}>
                <FormControl fullWidth error={formik.touched.category && Boolean(formik.errors.category)}>
                  <InputLabel>Category *</InputLabel>
                  <Select
                    name="category"
                    value={formik.values.category}
                    onChange={formik.handleChange}
                    onBlur={formik.handleBlur}
                    label="Category *"
                    disabled={isSubmitting}
                  >
                    {categories.map((category) => (
                      <MenuItem key={category.value} value={category.value}>
                        {category.label}
                      </MenuItem>
                    ))}
                  </Select>
                  {formik.touched.category && formik.errors.category && (
                    <FormHelperText error>{formik.errors.category}</FormHelperText>
                  )}
                </FormControl>
              </Grid>

              {/* Status (editable by admin only) */}
              {isAdmin && (
                <Grid item xs={12} md={6}>
                  <FormControl fullWidth error={formik.touched.status && Boolean(formik.errors.status)}>
                    <InputLabel>Status *</InputLabel>
                    <Select
                      name="status"
                      value={formik.values.status}
                      onChange={formik.handleChange}
                      onBlur={formik.handleBlur}
                      label="Status *"
                      disabled={isSubmitting}
                    >
                      <MenuItem value="pending">Pending</MenuItem>
                      <MenuItem value="approved">Approved</MenuItem>
                      <MenuItem value="rejected">Rejected</MenuItem>
                    </Select>
                    {formik.touched.status && formik.errors.status && (
                      <FormHelperText error>{formik.errors.status}</FormHelperText>
                    )}
                  </FormControl>
                </Grid>
              )}

              {/* Receipt URL */}
              <Grid item xs={12}>
                <TextField
                  fullWidth
                  label="Receipt URL (optional)"
                  name="receiptUrl"
                  value={formik.values.receiptUrl || ''}
                  onChange={formik.handleChange}
                  onBlur={formik.handleBlur}
                  error={formik.touched.receiptUrl && Boolean(formik.errors.receiptUrl)}
                  helperText={formik.touched.receiptUrl && formik.errors.receiptUrl}
                  disabled={isSubmitting}
                />
              </Grid>

              {/* Form Actions */}
              <Grid item xs={12}>
                <Box display="flex" justifyContent="flex-end" gap={2}>
                  <Button 
                    variant="outlined" 
                    onClick={handleCancel}
                    disabled={isSubmitting}
                  >
                    Cancel
                  </Button>
                  <Button 
                    type="submit" 
                    variant="contained"
                    color="primary"
                    disabled={isSubmitting || !formik.isValid}
                    startIcon={isSubmitting ? <CircularProgress size={20} /> : null}
                  >
                    {isEditMode ? 'Update' : 'Create'} Expense
                  </Button>
                </Box>
              </Grid>
            </Grid>
          </CardContent>
        </Card>
      </form>
    </LocalizationProvider>
  );
};
                        {project.name}
                      </MenuItem>
                    ))}
                  </Select>
                  {formik.touched.projectId && formik.errors.projectId && (
                    <FormHelperText error>{formik.errors.projectId}</FormHelperText>
                  )}
                </FormControl>
              </Grid>

              {/* Date */}
              <Grid item xs={12} md={6}>
                <DatePicker
                  label="Date *"
                  value={formik.values.date}
                  onChange={(date) => formik.setFieldValue('date', date)}
                  renderInput={(params) => (
                    <TextField
                      {...params}
                      fullWidth
                      error={formik.touched.date && Boolean(formik.errors.date)}
                      helperText={formik.touched.date && formik.errors.date}
                    />
                  )}
                />
              </Grid>

              {/* Amount */}
              <Grid item xs={12} md={6}>
                <TextField
                  fullWidth
                  label="Amount *"
                  name="amount"
                  type="number"
                  value={formik.values.amount}
                  onChange={formik.handleChange}
                  onBlur={formik.handleBlur}
                  error={formik.touched.amount && Boolean(formik.errors.amount)}
                  helperText={formik.touched.amount && formik.errors.amount}
                  InputProps={{
                    startAdornment: (
                      <InputAdornment position="start">MWK</InputAdornment>
                    ),
                  }}
                />
              </Grid>

              {/* Description */}
              <Grid item xs={12}>
                <TextField
                  fullWidth
                  label="Description *"
                  name="description"
                  multiline
                  rows={3}
                  value={formik.values.description}
                  onChange={formik.handleChange}
                  onBlur={formik.handleBlur}
                  error={formik.touched.description && Boolean(formik.errors.description)}
                  helperText={formik.touched.description && formik.errors.description}
                />
              </Grid>

              {/* Category */}
              <Grid item xs={12} md={6}>
                <FormControl 
                  fullWidth 
                  error={formik.touched.category && Boolean(formik.errors.category)}
                >
                  <InputLabel>Category *</InputLabel>
                  <Select
                    name="category"
                    value={formik.values.category}
                    onChange={formik.handleChange}
                    onBlur={formik.handleBlur}
                    label="Category *"
                  >
                    <MenuItem value="office">Office Supplies</MenuItem>
                    <MenuItem value="travel">Travel</MenuItem>
                    <MenuItem value="utilities">Utilities</MenuItem>
                    <MenuItem value="equipment">Equipment</MenuItem>
                    <MenuItem value="other">Other</MenuItem>
                  </Select>
                  {formik.touched.category && formik.errors.category && (
                    <FormHelperText error>{formik.errors.category}</FormHelperText>
                  )}
                </FormControl>
              </Grid>

              {/* Status (editable by admin only) */}
              {isAdmin && (
                <Grid item xs={12} md={6}>
                  <FormControl fullWidth>
                    <InputLabel>Status *</InputLabel>
                    <Select
                      name="status"
                      value={formik.values.status}
                      onChange={formik.handleChange}
                      onBlur={formik.handleBlur}
                      label="Status *"
                    >
                      <MenuItem value="pending">Pending</MenuItem>
                      <MenuItem value="approved">Approved</MenuItem>
                      <MenuItem value="rejected">Rejected</MenuItem>
                    </Select>
                  </FormControl>
                </Grid>
              )}

              {/* Form Actions */}
              <Grid item xs={12}>
                <Box display="flex" justifyContent="flex-end" gap={2}>
                  <Button 
                    variant="outlined" 
                    onClick={handleCancel}
                    disabled={formik.isSubmitting}
                  >
                    Cancel
                  </Button>
                  <Button 
                    type="submit" 
                    variant="contained"
                    disabled={formik.isSubmitting}
                    startIcon={formik.isSubmitting ? <CircularProgress size={20} /> : null}
                  >
                    {isEditMode ? 'Update' : 'Create'} Expense
                  </Button>
                </Box>
              </Grid>
                    <InputLabel>Project *</InputLabel>
                    <Select
                      name="projectId"
                      value={formik.values.projectId}
                      onChange={formik.handleChange}
                      onBlur={formik.handleBlur}
                      label="Project *"
                      disabled={isLoading}
                    >
                      {projectsData?.map((project: any) => (
                        <MenuItem key={project.id} value={project.id}>
                          {project.name}
                        </MenuItem>
                      ))}
                    </Select>
                    <FormHelperText>
                      {formik.touched.projectId && formik.errors.projectId}
                    </FormHelperText>
                  </FormControl>
                </Grid>
              )}
              
              <Grid item xs={12} sm={4}>
                <TextField
                  fullWidth
                  label="Quantity *"
                  name="quantity"
                  type="number"
                  value={formik.values.quantity}
                  onChange={formik.handleChange}
                  onBlur={formik.handleBlur}
                  error={formik.touched.quantity && Boolean(formik.errors.quantity)}
                  helperText={formik.touched.quantity && formik.errors.quantity}
                  InputProps={{
                    startAdornment: <InputAdornment position="start">#</InputAdornment>,
                    inputProps: { min: 1, step: 1 },
                  }}
                />
              </Grid>
              
              <Grid item xs={12} sm={4}>
                <TextField
                  fullWidth
                  label="Unit Price (MWK) *"
                  name="unitPrice"
                  type="number"
                  value={formik.values.unitPrice}
                  onChange={(e) => {
                    const value = parseFloat(e.target.value);
                    formik.setFieldValue('unitPrice', isNaN(value) ? '' : value);
                    // Recalculate amount if quantity is set
                    if (formik.values.quantity) {
                      formik.setFieldValue('amount', (isNaN(value) ? 0 : value) * formik.values.quantity);
                    }
                  }}
                  onBlur={formik.handleBlur}
                  error={formik.touched.unitPrice && Boolean(formik.errors.unitPrice)}
                  helperText={formik.touched.unitPrice && formik.errors.unitPrice}
                  InputProps={{
                    startAdornment: <InputAdornment position="start">MK</InputAdornment>,
                  }}
                />
              </Grid>

              <LocalizationProvider dateAdapter={AdapterDateFns}>
                <Grid item xs={12} sm={4}>
                  <DatePicker
                    label="Expense Date *"
                    value={formik.values.date}
                    onChange={(newValue) => {
                      formik.setFieldValue('date', newValue || new Date());
                    }}
                    maxDate={new Date()}
                    renderInput={(params) => (
                      <TextField
                        {...params}
                        fullWidth
                        error={formik.touched.date && Boolean(formik.errors.date)}
                        helperText={formik.touched.date && formik.errors.date}
                      />
                    )}
                  />
                </Grid>
              </LocalizationProvider>

              {/* Amount */}
              <Grid item xs={12} sm={4}>
                <TextField
                  fullWidth
                  label="Amount (MWK) *"
                  name="amount"
                  type="number"
                  value={formik.values.amount}
                  onChange={(e) => {
                    formik.setFieldValue('amount', e.target.value);
                  }}
                  onBlur={formik.handleBlur}
                  error={formik.touched.amount && Boolean(formik.errors.amount)}
                  helperText={formik.touched.amount && formik.errors.amount}
                  disabled={isLoading}
                  InputProps={{
                    startAdornment: (
                      <InputAdornment position="start">
                        MK
                      </InputAdornment>
                    ),
                    inputProps: { min: 0.01, step: 0.01 },
                  }}
                />
              </Grid>

              {/* Description */}
              <Grid item xs={12}>
                <TextField
                  fullWidth
                  label="Description"
                  name="description"
                  multiline
                  rows={3}
                  value={formik.values.description}
                  onChange={formik.handleChange}
                  onBlur={formik.handleBlur}
                  error={formik.touched.description && Boolean(formik.errors.description)}
                  helperText={
                    formik.touched.description && formik.errors.description 
                      ? formik.errors.description 
                      : `${formik.values.description?.length || 0}/500`
                  }
                  disabled={isLoading}
                  InputProps={{
                    startAdornment: (
                      <InputAdornment position="start">
                        <DescriptionIcon color="action" />
                      </InputAdornment>
                    ),
                  }}
                />
              </Grid>

              <Grid item xs={12} md={6}>
                <TextField
                  fullWidth
                  label="Created Date"
                  value={formik.values.createdAt ? new Date(formik.values.createdAt).toLocaleString() : 'N/A'}
                  disabled
                  InputLabelProps={{
                    shrink: true,
                  }}
                  helperText="Automatically set when expense is created"
                />
              </Grid>
              
              <Grid item xs={12} md={6}>
                <FormControl fullWidth error={formik.touched.category && Boolean(formik.errors.category)}>
                  <InputLabel>Category *</InputLabel>
                  <Select
                    name="category"
                    value={formik.values.category}
                    onChange={formik.handleChange}
                    onBlur={formik.handleBlur}
                    label="Category *"
                    disabled={isLoading}
                  >
                    <MenuItem value="">Select a category</MenuItem>
                    <MenuItem value="Materials - Concrete">Materials - Concrete</MenuItem>
                    <MenuItem value="Materials - Steel">Materials - Steel</MenuItem>
                    <MenuItem value="Materials - Lumber">Materials - Lumber</MenuItem>
                    <MenuItem value="Materials - Bricks/Blocks">Materials - Bricks/Blocks</MenuItem>
                    <MenuItem value="Materials - Roofing">Materials - Roofing</MenuItem>
                    <MenuItem value="Materials - Electrical">Materials - Electrical</MenuItem>
                    <MenuItem value="Materials - Plumbing">Materials - Plumbing</MenuItem>
                    <MenuItem value="Materials - Paint">Materials - Paint</MenuItem>
                    <MenuItem value="Materials - Tiles">Materials - Tiles</MenuItem>
                    <MenuItem value="Materials - Glass">Materials - Glass</MenuItem>
                    <MenuItem value="Labor - Masons">Labor - Masons</MenuItem>
                    <MenuItem value="Labor - Carpenters">Labor - Carpenters</MenuItem>
                    <MenuItem value="Labor - Electricians">Labor - Electricians</MenuItem>
                    <MenuItem value="Labor - Plumbers">Labor - Plumbers</MenuItem>
                    <MenuItem value="Labor - Painters">Labor - Painters</MenuItem>
                    <MenuItem value="Labor - General Workers">Labor - General Workers</MenuItem>
                    <MenuItem value="Equipment - Rental">Equipment - Rental</MenuItem>
                    <MenuItem value="Equipment - Fuel">Equipment - Fuel</MenuItem>
                    <MenuItem value="Equipment - Maintenance">Equipment - Maintenance</MenuItem>
                    <MenuItem value="Site Preparation - Clearing">Site Preparation - Clearing</MenuItem>
                    <MenuItem value="Site Preparation - Excavation">Site Preparation - Excavation</MenuItem>
                    <MenuItem value="Site Preparation - Foundation">Site Preparation - Foundation</MenuItem>
                    <MenuItem value="Permits and Fees">Permits and Fees</MenuItem>
                    <MenuItem value="Architect/Engineer Fees">Architect/Engineer Fees</MenuItem>
                    <MenuItem value="Surveying">Surveying</MenuItem>
                    <MenuItem value="Waste Removal">Waste Removal</MenuItem>
                    <MenuItem value="Security">Security</MenuItem>
                    <MenuItem value="Utilities - Water">Utilities - Water</MenuItem>
                    <MenuItem value="Utilities - Electricity">Utilities - Electricity</MenuItem>
                    <MenuItem value="Utilities - Internet/Phone">Utilities - Internet/Phone</MenuItem>
                    <MenuItem value="Office Supplies">Office Supplies</MenuItem>
                    <MenuItem value="Transportation">Transportation</MenuItem>
                    <MenuItem value="Accommodation">Accommodation</MenuItem>
                    <MenuItem value="Meals">Meals</MenuItem>
                    <MenuItem value="Insurance">Insurance</MenuItem>
                    <MenuItem value="Contingency">Contingency</MenuItem>
                    <MenuItem value="Other">Other</MenuItem>
                  </Select>
                  <FormHelperText>{formik.touched.category && formik.errors.category}</FormHelperText>
                </FormControl>
              </Grid>

              {(isEditMode && isAdmin) && (
                <Grid item xs={12} md={6}>
                  <FormControl fullWidth>
                    <InputLabel>Status</InputLabel>
                    <Select
                      name="status"
                      value={formik.values.status}
                      onChange={formik.handleChange}
                      onBlur={formik.handleBlur}
                      label="Status"
                      disabled={isLoading}
                    >
                      <MenuItem value="pending">
                        <Box display="flex" alignItems="center" gap={1}>
                          <PendingActionsIcon fontSize="small" color="warning" />
                          <span>Pending</span>
                        </Box>
                      </MenuItem>
                      <MenuItem value="approved">
                        <Box display="flex" alignItems="center" gap={1}>
                          <CheckCircleIcon fontSize="small" color="success" />
                          <span>Approved</span>
                        </Box>
                      </MenuItem>
                      <MenuItem value="rejected">
                        <Box display="flex" alignItems="center" gap={1}>
                          <CancelIcon fontSize="small" color="error" />
                          <span>Rejected</span>
                        </Box>
                      </MenuItem>
                    </Select>
                  </FormControl>
                </Grid>
              )}
            </Grid>
          </CardContent>
          <Divider />
          <Box sx={{ display: 'flex', justifyContent: 'flex-end', p: 2 }}>
            <Button
              variant="outlined"
              onClick={() => navigate(-1)}
              disabled={isLoading}
            >
              Cancel
          </CardContent>
        </Card>
      </form>
    </LocalizationProvider>
  );
};

export default ExpenseForm;
